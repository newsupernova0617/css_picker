"""
CSS Picker Backend (Flask)
- Clerk 인증 (JWT 기반)
- Stripe 결제 처리 (일회성 평생 플랜)
- Turso (SQLite 호환) + SQLAlchemy ORM
- 사용자 프로필 / 결제 / 웹훅 API 제공
"""
from typing import Generator
import os
import hashlib
import logging
from datetime import datetime
from typing import Optional, Dict

import requests
import stripe
import jwt

from dotenv import load_dotenv
from flask import Flask, request, jsonify, render_template, g
from flask_cors import CORS
from functools import wraps
from werkzeug.exceptions import BadRequest

from sqlalchemy import (
    create_engine, Column, String, DateTime, ForeignKey, Integer, func
)
from sqlalchemy.orm import declarative_base, relationship, sessionmaker, Session

# ======================
#  환경설정 및 초기화
# ======================

load_dotenv()

# Flask 초기화
app = Flask(__name__)
CORS(app)

# 기본 설정
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'your-secret-key-here')

# Stripe 설정
stripe.api_key = os.getenv('STRIPE_SECRET_KEY', 'sk_test_your_stripe_secret_key_here')
STRIPE_WEBHOOK_SECRET = os.getenv('STRIPE_WEBHOOK_SECRET', 'whsec_your_webhook_secret')
STRIPE_PRICE_ID = os.getenv('STRIPE_PRICE_ID', 'price_your_premium_price_id')

# Clerk 설정
CLERK_SECRET_KEY = os.getenv('CLERK_SECRET_KEY')

# Turso (SQLite 호환) + SQLAlchemy ORM
TURSO_DATABASE_URL = os.getenv('TURSO_DATABASE_URL', 'sqlite:///app.db')
engine = create_engine(
    TURSO_DATABASE_URL.replace("libsql://", "sqlite:///", 1),
    connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# 로깅 설정
logging.basicConfig(level=logging.INFO)


# ======================
#  데이터베이스 모델
# ======================

class User(Base):
    __tablename__ = "users"

    id = Column(String, primary_key=True, index=True)
    clerk_user_id = Column(String, unique=True, nullable=False, index=True)
    email = Column(String, nullable=False)
    plan = Column(String, default="free")
    premium_activated_at = Column(DateTime)
    stripe_customer_id = Column(String)
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())

    payments = relationship("Payment", back_populates="user")


class Payment(Base):
    __tablename__ = "payments"

    id = Column(String, primary_key=True, index=True)
    user_id = Column(String, ForeignKey("users.id"))
    stripe_payment_intent_id = Column(String, unique=True)
    amount = Column(Integer, nullable=False)
    status = Column(String, nullable=False)
    payment_date = Column(DateTime)
    created_at = Column(DateTime, server_default=func.now())

    user = relationship("User", back_populates="payments")


Base.metadata.create_all(bind=engine)


# ======================
#  유틸 함수
# ======================




def error_response(message: str, status_code: int = 500):
    """일관된 에러 응답"""
    logging.error(message)
    return jsonify({'error': message}), status_code
# ======================
#  요청 단위 세션 관리
# ======================
@app.before_request
def create_session():
    g.db = SessionLocal()

@app.teardown_request
def remove_session(exception=None):
    db = getattr(g, "db", None)
    if db:
        try:
            if exception:
                db.rollback()
        except Exception as e:
            logging.warning(f"DB rollback 중 오류 발생: {e}")
        finally:
            try:
                db.close()
            except Exception as e:
                logging.warning(f"DB close 중 오류 발생: {e}")

# ======================
#  Clerk 인증
# ======================

def fetch_jwks() -> dict:
    """Clerk JWKS 키셋 가져오기"""
    jwks_url = "https://meet-warthog-82.clerk.accounts.dev/.well-known/jwks.json"
    response = requests.get(jwks_url)
    response.raise_for_status()
    return response.json()


def get_public_key_from_jwks(token: str, jwks: dict):
    """JWT 헤더 kid에 맞는 공개키 추출"""
    unverified_header = jwt.get_unverified_header(token)
    kid = unverified_header.get("kid")

    for jwk in jwks["keys"]:
        if jwk["kid"] == kid:
            return jwt.algorithms.RSAAlgorithm.from_jwk(jwk)

    raise ValueError("JWKS에서 일치하는 키를 찾을 수 없음")


def decode_clerk_jwt(token: str, key) -> dict:
    """Clerk JWT 디코딩"""
    return jwt.decode(
        token,
        key,
        algorithms=["RS256"],
        options={"verify_aud": False}
    )


def fetch_user_data_from_clerk(user_id: str) -> Optional[Dict]:
    """Clerk API에서 사용자 데이터 가져오기"""
    headers = {'Authorization': f'Bearer {CLERK_SECRET_KEY}'}
    user_url = f"https://api.clerk.com/v1/users/{user_id}"
    response = requests.get(user_url, headers=headers)

    if response.status_code == 200:
        user_data = response.json()
        return {
            "user_id": user_id,
            "email": user_data.get("email_addresses", [{}])[0].get("email_address"),
            "first_name": user_data.get("first_name"),
            "last_name": user_data.get("last_name")
        }
    return None


def verify_clerk_session_token(token: str) -> Optional[Dict]:
    """Clerk JWT 세션 토큰 검증"""
    try:
        jwks = fetch_jwks()
        key = get_public_key_from_jwks(token, jwks)
        payload = decode_clerk_jwt(token, key)
        return fetch_user_data_from_clerk(payload["sub"])
    except Exception as e:
        logging.error(f"Clerk 토큰 검증 실패: {e}")
        return None


def verify_clerk_token(f):
    """Clerk 인증 토큰 검증 데코레이터"""

    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            return error_response("Authorization 헤더 없음", 401)

        token = auth_header.split(" ")[1]
        user_data = verify_clerk_session_token(token)

        if not user_data:
            return error_response("잘못되거나 만료된 토큰", 401)

        request.user_id = user_data["user_id"]
        request.user_email = user_data["email"]
        return f(*args, **kwargs)

    return decorated


# ======================
#  사용자 관리
# ======================

def get_or_create_user(db: Session, clerk_user_id: str, email: str) -> User:
    """기존 사용자 조회 또는 신규 생성"""
    user = db.query(User).filter(User.clerk_user_id == clerk_user_id).first()
    if user:
        return user

    user_id = f"usr_{hashlib.md5(clerk_user_id.encode()).hexdigest()[:12]}"
    user = User(id=user_id, clerk_user_id=clerk_user_id, email=email, plan="free")
    db.add(user)
    db.commit()
    db.refresh(user)
    return user


# ======================
#  라우트
# ======================

@app.route("/")
def index():
    return render_template("index.html")


@app.route("/health")
def health():
    return jsonify({"status": "healthy", "timestamp": datetime.now().isoformat()})


@app.route("/api/user/profile", methods=["GET", "POST"])
@verify_clerk_token
def handle_user_profile():
    """사용자 프로필 GET/POST"""
    try:
        db = g.db
        user = get_or_create_user(db, request.user_id, request.user_email)
        return jsonify({
            "id": user.id,
            "email": user.email,
            "plan": user.plan,
            "premium_activated_at": user.premium_activated_at,
            "created_at": user.created_at
        })
    except Exception as e:
        return error_response(f"사용자 프로필 오류: {e}", 500)


@app.route("/api/checkout/create", methods=["POST"])
@verify_clerk_token
def create_checkout():
    """Stripe 체크아웃 세션 생성"""
    try:
        db = g.db
        user = get_or_create_user(db, request.user_id, request.user_email)

        if not user.stripe_customer_id:
            customer = stripe.Customer.create(
                email=user.email,
                metadata={"user_id": user.id}
            )
            user.stripe_customer_id = customer.id
            db.commit()

        session = stripe.checkout.Session.create(
            customer=user.stripe_customer_id,
            payment_method_types=["card"],
            line_items=[{"price": STRIPE_PRICE_ID, "quantity": 1}],
            mode="payment",
            success_url=request.host_url + "success?session_id={CHECKOUT_SESSION_ID}",
            cancel_url=request.host_url + "cancel",
            metadata={"user_id": user.id}
        )

        return jsonify({"checkout_url": session.url, "session_id": session.id})
    except Exception as e:
        return error_response(f"체크아웃 생성 오류: {e}", 500)


# ======================
#  Stripe 웹훅
# ======================

@app.route("/webhooks/stripe", methods=["POST"])
def stripe_webhook():
    """Stripe 웹훅 처리"""
    payload = request.get_data()
    sig_header = request.headers.get("Stripe-Signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return error_response(f"웹훅 검증 실패: {e}", 400)

    db = g.db

    if event["type"] == "checkout.session.completed":
        handle_checkout_completed(db, event["data"]["object"])

    return "", 200


def handle_checkout_completed(db: Session, session: dict):
    """체크아웃 완료 처리"""
    try:
        user_id = session["metadata"]["user_id"]
        payment_intent_id = session["payment_intent"]

        user = db.query(User).filter(User.id == user_id).first()
        if user:
            user.plan = "premium"
            user.premium_activated_at = func.now()

            payment_id = f"pay_{hashlib.md5(payment_intent_id.encode()).hexdigest()[:12]}"
            payment = Payment(
                id=payment_id,
                user_id=user_id,
                stripe_payment_intent_id=payment_intent_id,
                amount=2900,
                status="succeeded",
                payment_date=func.now()
            )
            db.add(payment)
            db.commit()
            logging.info(f"사용자 {user_id} 프리미엄 업그레이드 완료")
    except Exception as e:
        logging.error(f"체크아웃 완료 처리 오류: {e}")


# ======================
#  실행
# ======================

if __name__ == "__main__":
    port = int(os.getenv("PORT", 4242))
    debug = os.getenv("FLASK_DEBUG", "False").lower() == "true"
    app.run(debug=debug, host="0.0.0.0", port=port)
